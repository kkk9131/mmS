-- ===============================
-- セキュリティ脆弱性修正スクリプト
-- ===============================
-- 発見された脆弱性の修正とセキュリティ強化

-- 1. 認証バイパス脆弱性修正：空文字列・NULL値での認証を防ぐ
-- auth_with_maternal_book関数を強化バージョンに置き換え
CREATE OR REPLACE FUNCTION auth_with_maternal_book(
  maternal_book_param text,
  user_nickname_param text
)
RETURNS TABLE(
  user_id UUID,
  access_token text,
  refresh_token text,
  profile_data JSONB
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  existing_user_id UUID;
  new_user_id UUID;
  user_profile RECORD;
  sanitized_nickname text;
BEGIN
  -- 🛡️ セキュリティ検証1: 入力値の検証
  -- 空文字列、NULL値、不正な文字列の検証
  IF maternal_book_param IS NULL OR 
     trim(maternal_book_param) = '' OR 
     length(trim(maternal_book_param)) < 3 THEN
    RAISE EXCEPTION 'Invalid maternal book number: must be at least 3 characters' 
      USING ERRCODE = 'invalid_parameter_value';
  END IF;

  IF user_nickname_param IS NULL OR 
     trim(user_nickname_param) = '' OR 
     length(trim(user_nickname_param)) < 1 THEN
    RAISE EXCEPTION 'Invalid nickname: must not be empty' 
      USING ERRCODE = 'invalid_parameter_value';
  END IF;

  -- 🛡️ セキュリティ検証2: 母子手帳番号の形式検証
  -- 英数字と特定の記号のみ許可（日本の母子手帳番号形式）
  IF NOT maternal_book_param ~ '^[A-Za-z0-9\-_\.]{3,50}$' THEN
    RAISE EXCEPTION 'Invalid maternal book number format' 
      USING ERRCODE = 'invalid_parameter_value';
  END IF;

  -- 🛡️ セキュリティ検証3: ニックネームのサニタイゼーション
  -- XSS攻撃防止のためHTMLタグとJavaScriptを除去
  sanitized_nickname := regexp_replace(
    regexp_replace(
      regexp_replace(
        regexp_replace(
          regexp_replace(user_nickname_param, '<[^>]*>', '', 'g'), -- HTMLタグ除去
          'javascript:', '', 'gi'), -- JavaScript除去
        'on\w+\s*=', '', 'gi'), -- イベントハンドラ除去
      '&lt;.*?&gt;', '', 'g'), -- エンコード済みHTMLタグ除去
    '[<>&"''\x00-\x1F\x7F]', '', 'g'); -- 特殊文字と制御文字除去

  -- サニタイズ後の長さ検証
  IF length(trim(sanitized_nickname)) < 1 THEN
    RAISE EXCEPTION 'Nickname contains only invalid characters' 
      USING ERRCODE = 'invalid_parameter_value';
  END IF;

  -- 長すぎるニックネームの制限
  IF length(sanitized_nickname) > 50 THEN
    sanitized_nickname := left(sanitized_nickname, 50);
  END IF;

  -- 既存ユーザーをmaternal_book_numberで検索
  SELECT u.id INTO existing_user_id 
  FROM public.users u
  WHERE u.maternal_book_number = trim(maternal_book_param);
  
  IF existing_user_id IS NOT NULL THEN
    -- 🛡️ 既存ユーザーの場合、セッション固定攻撃を防ぐため新しいトークンを生成
    UPDATE public.users 
    SET nickname = sanitized_nickname, 
        updated_at = NOW(),
        -- セッション情報を更新してセッション固定を防ぐ
        last_sign_in_at = NOW()
    WHERE id = existing_user_id;
    
    -- プロフィール情報を取得
    SELECT u.* INTO user_profile 
    FROM public.users u
    WHERE u.id = existing_user_id;
    
    -- 🛡️ セッション固定攻撃防止：新しいトークンを生成
    -- タイムスタンプとランダム要素を含む安全なトークン
    RETURN QUERY SELECT 
      existing_user_id,
      'secure_access_' || existing_user_id::TEXT || '_' || extract(epoch from NOW())::TEXT || '_' || gen_random_uuid()::TEXT,
      'secure_refresh_' || existing_user_id::TEXT || '_' || extract(epoch from NOW())::TEXT || '_' || gen_random_uuid()::TEXT,
      jsonb_build_object(
        'id', user_profile.id,
        'nickname', user_profile.nickname,
        'bio', user_profile.bio,
        'avatar_url', user_profile.avatar_url,
        'created_at', user_profile.created_at,
        'updated_at', user_profile.updated_at,
        'is_anonymous', user_profile.is_anonymous,
        'privacy_settings', user_profile.privacy_settings,
        -- 🛡️ 機密情報（母子手帳番号）はプロフィールデータから除外
        'maternal_book_number', '***PROTECTED***'
      );
  ELSE
    -- 新規ユーザーの場合
    new_user_id := gen_random_uuid();
    
    -- 🛡️ レート制限チェック（同一IPからの大量登録防止）
    -- 実装は省略（アプリケーションレベルで実装推奨）
    
    -- auth.usersに挿入（Supabase認証テーブル）
    INSERT INTO auth.users (
      id, 
      email, 
      encrypted_password, 
      email_confirmed_at,
      created_at,
      updated_at,
      raw_app_meta_data,
      raw_user_meta_data,
      is_super_admin,
      role
    ) VALUES (
      new_user_id,
      trim(maternal_book_param) || '@maternal.book',
      crypt('secure_dummy_' || gen_random_uuid()::TEXT, gen_salt('bf')), -- より安全なダミーパスワード
      NOW(),
      NOW(),
      NOW(),
      '{"provider": "maternal_book", "security_version": "2.0"}'::JSONB,
      jsonb_build_object(
        'nickname', sanitized_nickname, 
        'maternal_book_number', trim(maternal_book_param),
        'registration_timestamp', extract(epoch from NOW())
      ),
      false,
      'authenticated'
    );
    
    -- public.usersテーブルに詳細情報を挿入
    INSERT INTO public.users (
      id,
      nickname,
      maternal_book_number,
      created_at,
      updated_at,
      last_sign_in_at,
      privacy_settings
    ) VALUES (
      new_user_id,
      sanitized_nickname,
      trim(maternal_book_param),
      NOW(),
      NOW(),
      NOW(),
      jsonb_build_object(
        'profile_visible', true,
        'posts_visible', true,
        'allow_notifications', true
      )
    );
    
    -- 新規作成されたプロフィール情報を取得
    SELECT u.* INTO user_profile 
    FROM public.users u
    WHERE u.id = new_user_id;
    
    -- 🛡️ 新規ユーザーにも安全なトークンを生成
    RETURN QUERY SELECT 
      new_user_id,
      'secure_access_' || new_user_id::TEXT || '_' || extract(epoch from NOW())::TEXT || '_' || gen_random_uuid()::TEXT,
      'secure_refresh_' || new_user_id::TEXT || '_' || extract(epoch from NOW())::TEXT || '_' || gen_random_uuid()::TEXT,
      jsonb_build_object(
        'id', user_profile.id,
        'nickname', user_profile.nickname,
        'bio', user_profile.bio,
        'avatar_url', user_profile.avatar_url,
        'created_at', user_profile.created_at,
        'updated_at', user_profile.updated_at,
        'is_anonymous', user_profile.is_anonymous,
        'privacy_settings', user_profile.privacy_settings,
        -- 🛡️ 機密情報（母子手帳番号）はプロフィールデータから除外
        'maternal_book_number', '***PROTECTED***'
      );
  END IF;

EXCEPTION
  WHEN invalid_parameter_value THEN
    -- セキュリティエラーは詳細を隠す
    RAISE EXCEPTION 'Authentication failed: Invalid credentials' 
      USING ERRCODE = 'authentication_failure';
  WHEN OTHERS THEN
    -- その他のエラーも詳細を隠す
    RAISE EXCEPTION 'Authentication system error' 
      USING ERRCODE = 'system_error';
END;
$$;

-- 2. 新しいサニタイゼーション関数の作成
CREATE OR REPLACE FUNCTION sanitize_user_input(input_text text)
RETURNS text
LANGUAGE plpgsql
IMMUTABLE
AS $$
BEGIN
  IF input_text IS NULL THEN
    RETURN '';
  END IF;
  
  -- XSS攻撃防止のための包括的なサニタイゼーション
  RETURN regexp_replace(
    regexp_replace(
      regexp_replace(
        regexp_replace(
          regexp_replace(
            regexp_replace(input_text, 
              '<[^>]*>', '', 'g'), -- HTMLタグ除去
            'javascript:', '', 'gi'), -- JavaScript除去
          'on\w+\s*=', '', 'gi'), -- イベントハンドラ除去
        '&lt;.*?&gt;', '', 'g'), -- エンコード済みHTMLタグ除去
      '&[a-zA-Z0-9#]+;', '', 'g'), -- HTMLエンティティ除去
    '[<>&"''\x00-\x1F\x7F]', '', 'g'); -- 危険な文字と制御文字除去
END;
$$;

-- 3. ユーザープロフィール更新時のサニタイゼーション強化
CREATE OR REPLACE FUNCTION update_user_profile_secure()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  -- ニックネームのサニタイゼーション
  IF NEW.nickname IS NOT NULL THEN
    NEW.nickname := sanitize_user_input(NEW.nickname);
    
    -- 空文字列チェック
    IF trim(NEW.nickname) = '' THEN
      RAISE EXCEPTION 'Nickname cannot be empty after sanitization';
    END IF;
    
    -- 長さ制限
    IF length(NEW.nickname) > 50 THEN
      NEW.nickname := left(NEW.nickname, 50);
    END IF;
  END IF;
  
  -- bioのサニタイゼーション
  IF NEW.bio IS NOT NULL THEN
    NEW.bio := sanitize_user_input(NEW.bio);
    
    -- 長さ制限
    IF length(NEW.bio) > 500 THEN
      NEW.bio := left(NEW.bio, 500);
    END IF;
  END IF;
  
  -- 更新日時の設定
  NEW.updated_at := NOW();
  
  RETURN NEW;
END;
$$;

-- 4. トリガーの作成（既存トリガーがある場合は削除してから作成）
DROP TRIGGER IF EXISTS secure_user_update ON public.users;
CREATE TRIGGER secure_user_update
  BEFORE UPDATE ON public.users
  FOR EACH ROW
  EXECUTE FUNCTION update_user_profile_secure();

-- 5. 投稿データのサニタイゼーション強化
CREATE OR REPLACE FUNCTION secure_post_content()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  -- タイトルのサニタイゼーション
  IF NEW.title IS NOT NULL THEN
    NEW.title := sanitize_user_input(NEW.title);
    
    IF length(NEW.title) > 200 THEN
      NEW.title := left(NEW.title, 200);
    END IF;
  END IF;
  
  -- 内容のサニタイゼーション
  IF NEW.content IS NOT NULL THEN
    NEW.content := sanitize_user_input(NEW.content);
    
    IF length(NEW.content) > 10000 THEN
      NEW.content := left(NEW.content, 10000);
    END IF;
  END IF;
  
  -- 更新日時の設定
  NEW.updated_at := NOW();
  
  RETURN NEW;
END;
$$;

-- 6. 投稿用トリガーの作成
DROP TRIGGER IF EXISTS secure_post_insert ON public.posts;
DROP TRIGGER IF EXISTS secure_post_update ON public.posts;

CREATE TRIGGER secure_post_insert
  BEFORE INSERT ON public.posts
  FOR EACH ROW
  EXECUTE FUNCTION secure_post_content();

CREATE TRIGGER secure_post_update
  BEFORE UPDATE ON public.posts
  FOR EACH ROW
  EXECUTE FUNCTION secure_post_content();

-- 7. コメント用のサニタイゼーション
CREATE OR REPLACE FUNCTION secure_comment_content()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  -- コメント内容のサニタイゼーション
  IF NEW.content IS NOT NULL THEN
    NEW.content := sanitize_user_input(NEW.content);
    
    IF trim(NEW.content) = '' THEN
      RAISE EXCEPTION 'Comment content cannot be empty';
    END IF;
    
    IF length(NEW.content) > 2000 THEN
      NEW.content := left(NEW.content, 2000);
    END IF;
  END IF;
  
  NEW.updated_at := NOW();
  
  RETURN NEW;
END;
$$;

-- 8. コメント用トリガーの作成
DROP TRIGGER IF EXISTS secure_comment_insert ON public.comments;
DROP TRIGGER IF EXISTS secure_comment_update ON public.comments;

CREATE TRIGGER secure_comment_insert
  BEFORE INSERT ON public.comments
  FOR EACH ROW
  EXECUTE FUNCTION secure_comment_content();

CREATE TRIGGER secure_comment_update
  BEFORE UPDATE ON public.comments
  FOR EACH ROW
  EXECUTE FUNCTION secure_comment_content();

-- 9. セキュリティ監査ログテーブルの作成
CREATE TABLE IF NOT EXISTS security_audit_log (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  event_type text NOT NULL,
  user_id UUID REFERENCES public.users(id),
  ip_address inet,
  user_agent text,
  event_data jsonb,
  risk_level text CHECK (risk_level IN ('low', 'medium', 'high', 'critical')),
  created_at timestamptz DEFAULT NOW()
);

-- 10. セキュリティ監査ログ用のRLSポリシー
ALTER TABLE security_audit_log ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Only service role can access audit logs" ON security_audit_log
  FOR ALL USING (auth.role() = 'service_role');

-- 11. セキュリティ監査ログ記録関数
CREATE OR REPLACE FUNCTION log_security_event(
  event_type_param text,
  user_id_param UUID DEFAULT NULL,
  risk_level_param text DEFAULT 'low',
  event_data_param jsonb DEFAULT NULL
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  INSERT INTO security_audit_log (
    event_type,
    user_id,
    risk_level,
    event_data
  ) VALUES (
    event_type_param,
    user_id_param,
    risk_level_param,
    event_data_param
  );
EXCEPTION
  WHEN OTHERS THEN
    -- 監査ログの失敗はメイン処理を止めない
    NULL;
END;
$$;

-- 12. auth_with_maternal_book関数にセキュリティ監査ログを追加
CREATE OR REPLACE FUNCTION auth_with_maternal_book_with_audit(
  maternal_book_param text,
  user_nickname_param text
)
RETURNS TABLE(
  user_id UUID,
  access_token text,
  refresh_token text,
  profile_data JSONB
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  result_record RECORD;
  auth_user_id UUID;
BEGIN
  -- セキュリティ監査ログ（認証試行）
  PERFORM log_security_event(
    'authentication_attempt',
    NULL,
    'medium',
    jsonb_build_object(
      'maternal_book_length', length(coalesce(maternal_book_param, '')),
      'nickname_length', length(coalesce(user_nickname_param, '')),
      'timestamp', extract(epoch from NOW())
    )
  );

  -- 元の認証関数を呼び出し
  FOR result_record IN 
    SELECT * FROM auth_with_maternal_book(maternal_book_param, user_nickname_param)
  LOOP
    auth_user_id := result_record.user_id;
    
    -- セキュリティ監査ログ（認証成功）
    PERFORM log_security_event(
      'authentication_success',
      auth_user_id,
      'low',
      jsonb_build_object(
        'timestamp', extract(epoch from NOW()),
        'new_tokens_generated', true
      )
    );
    
    RETURN QUERY SELECT 
      result_record.user_id,
      result_record.access_token,
      result_record.refresh_token,
      result_record.profile_data;
  END LOOP;

EXCEPTION
  WHEN OTHERS THEN
    -- セキュリティ監査ログ（認証失敗）
    PERFORM log_security_event(
      'authentication_failure',
      NULL,
      'high',
      jsonb_build_object(
        'error_code', SQLSTATE,
        'error_message', SQLERRM,
        'timestamp', extract(epoch from NOW())
      )
    );
    
    RAISE;
END;
$$;

-- 13. 関数の権限設定
GRANT EXECUTE ON FUNCTION auth_with_maternal_book TO anon, authenticated;
GRANT EXECUTE ON FUNCTION auth_with_maternal_book_with_audit TO anon, authenticated;
GRANT EXECUTE ON FUNCTION sanitize_user_input TO anon, authenticated;

-- 完了メッセージ
DO $$
BEGIN
  RAISE NOTICE '🛡️ セキュリティ脆弱性修正が完了しました';
  RAISE NOTICE '✅ 修正された脆弱性:';
  RAISE NOTICE '  1. 認証バイパス攻撃（空文字列・NULL値認証）';
  RAISE NOTICE '  2. Stored XSS攻撃（ニックネーム・投稿・コメント）';
  RAISE NOTICE '  3. セッション固定攻撃（新しいトークン生成）';
  RAISE NOTICE '  4. HTMLタグ・イベントハンドラインジェクション';
  RAISE NOTICE '  5. 機密情報漏洩（母子手帳番号マスキング）';
  RAISE NOTICE '';
  RAISE NOTICE '🔍 追加されたセキュリティ機能:';
  RAISE NOTICE '  - 包括的な入力値サニタイゼーション';
  RAISE NOTICE '  - セキュリティ監査ログシステム';
  RAISE NOTICE '  - 自動的なコンテンツフィルタリング';
  RAISE NOTICE '  - エラーメッセージの標準化';
END $$;